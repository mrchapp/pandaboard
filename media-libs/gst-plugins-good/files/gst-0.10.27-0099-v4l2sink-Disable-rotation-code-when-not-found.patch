From 606df19aa1230d0c6081e85d914c866eb7674a5a Mon Sep 17 00:00:00 2001
From: Daniel Diaz <ddiaz@ti.com>
Date: Fri, 28 Jan 2011 15:23:26 -0600
Subject: [PATCH] v4l2sink: Disable rotation code when not found.

Kernel headers might not include support for V4L2 rotation.

Signed-off-by: Daniel Diaz <ddiaz@ti.com>
---
 sys/v4l2/gstv4l2sink.c |   14 ++++++++++++++
 1 files changed, 14 insertions(+), 0 deletions(-)

diff --git a/sys/v4l2/gstv4l2sink.c b/sys/v4l2/gstv4l2sink.c
index ca6ae15..374de88 100644
--- a/sys/v4l2/gstv4l2sink.c
+++ b/sys/v4l2/gstv4l2sink.c
@@ -255,7 +255,9 @@ static GstFlowReturn gst_v4l2sink_buffer_alloc (GstBaseSink * bsink,
 static gboolean gst_v4l2sink_event (GstBaseSink * bsink, GstEvent * event);
 static GstFlowReturn gst_v4l2sink_show_frame (GstBaseSink * bsink,
     GstBuffer * buf);
+#ifdef V4L2_CID_ROTATE
 static void gst_v4l2sink_sync_rotation (GstV4l2Sink * v4l2sink);
+#endif
 
 static void
 gst_v4l2sink_base_init (gpointer g_class)
@@ -342,10 +344,12 @@ gst_v4l2sink_class_init (GstV4l2SinkClass * klass)
           "The height of the video crop; default is equal to negotiated image height",
           0, 0xffffffff, 0, G_PARAM_READWRITE));
 
+#ifdef V4L2_CID_ROTATE
   g_object_class_install_property (gobject_class, PROP_ROTATION,
       g_param_spec_int ("rotation", "Rotation angle",
           "Rotation angle for the image", MIN_ROTATION_ANGLE,
           MAX_ROTATION_ANGLE, DEFAULT_ROTATION_ANGLE, G_PARAM_READWRITE));
+#endif
 
   g_object_class_install_property (gobject_class, PROP_FLIP,
       g_param_spec_enum ("flip", "Flip State",
@@ -420,7 +424,9 @@ gst_v4l2sink_sync_flip (GstV4l2Sink * v4l2sink)
         break;
     }
 
+#ifdef V4L2_CID_ROTATE
     gst_v4l2sink_sync_rotation (v4l2sink);
+#endif
     control.id = V4L2_CID_VFLIP;
     g_return_if_fail (v4l2_ioctl (fd, VIDIOC_S_CTRL, &control) >= 0);
   }
@@ -562,6 +568,7 @@ gst_v4l2sink_sync_crop_fields (GstV4l2Sink * v4l2sink)
   }
 }
 
+#ifdef V4L2_CID_ROTATE
 static void
 gst_v4l2sink_sync_rotation (GstV4l2Sink * v4l2sink)
 {
@@ -575,6 +582,7 @@ gst_v4l2sink_sync_rotation (GstV4l2Sink * v4l2sink)
     g_return_if_fail (v4l2_ioctl (fd, VIDIOC_S_CTRL, &control) >= 0);
   }
 }
+#endif
 
 
 static void
@@ -632,10 +640,12 @@ gst_v4l2sink_set_property (GObject * object,
         v4l2sink->crop_fields_set |= RECT_HEIGHT_SET;
         gst_v4l2sink_sync_crop_fields (v4l2sink);
         break;
+#ifdef V4L2_CID_ROTATE
       case PROP_ROTATION:
         v4l2sink->rotation = g_value_get_int (value);
         gst_v4l2sink_sync_rotation (v4l2sink);
         break;
+#endif
       case PROP_FLIP:
         v4l2sink->flip = g_value_get_enum (value);
         gst_v4l2sink_sync_flip (v4l2sink);
@@ -687,9 +697,11 @@ gst_v4l2sink_get_property (GObject * object,
       case PROP_CROP_HEIGHT:
         g_value_set_uint (value, v4l2sink->crop.height);
         break;
+#ifdef V4L2_CID_ROTATE
       case PROP_ROTATION:
         g_value_set_int (value, v4l2sink->rotation);
         break;
+#endif
       case PROP_FLIP:
         g_value_set_enum (value, v4l2sink->flip);
         break;
@@ -715,7 +727,9 @@ gst_v4l2sink_change_state (GstElement * element, GstStateChange transition)
       /* open the device */
       if (!gst_v4l2_object_start (v4l2sink->v4l2object))
         return GST_STATE_CHANGE_FAILURE;
+#ifdef V4L2_CID_ROTATE
       gst_v4l2sink_sync_rotation (v4l2sink);
+#endif
       gst_v4l2sink_sync_flip (v4l2sink);
       break;
     default:
-- 
1.7.1

